# Compiler and Flags
CC = gcc
# -Isrc ensures that headers like ast.h located in src/ are found
CFLAGS = -Wall -g -w -Isrc

# Output Binary Name
TARGET = parser_w_fnb

# Directories
SRC_DIR = src

# Source Files
# We include the generated files (parser.tab.c, lex.yy.c) and the static ast.c
SRCS = $(SRC_DIR)/parser.tab.c $(SRC_DIR)/lex.yy.c $(SRC_DIR)/ast.c

# Default Rule (Type 'make' to run this)
all: $(TARGET)

# Link the final executable
# This compiles the source files and links them into the TARGET binary in the root folder
$(TARGET): $(SRCS)
	$(CC) $(CFLAGS) -o $(TARGET) $(SRCS)

# Generate Parser (Bison)
# -d creates the header file (parser.tab.h) needed by the lexer
# -o specifies that the output (.c and .h) should go into the src directory
$(SRC_DIR)/parser.tab.c $(SRC_DIR)/parser.tab.h: $(SRC_DIR)/parser.y
	bison -d $(SRC_DIR)/parser.y -o $(SRC_DIR)/parser.tab.c

# Generate Lexer (Flex)
# Depends on parser.tab.h because lexer.l includes token definitions
# -o specifies that the output (.c) should go into the src directory
$(SRC_DIR)/lex.yy.c: $(SRC_DIR)/lexer.l $(SRC_DIR)/parser.tab.h
	flex -o $(SRC_DIR)/lex.yy.c $(SRC_DIR)/lexer.l

# Clean Rule (Type 'make clean' to reset)
# Removes the binary and the files generated by Flex/Bison inside src/
clean:
	rm -f $(TARGET)
	rm -f $(SRC_DIR)/parser.tab.c $(SRC_DIR)/parser.tab.h $(SRC_DIR)/lex.yy.c
	rm -f $(SRC_DIR)/*.o